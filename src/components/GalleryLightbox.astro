---
type Item = {
  src: string;
  alt: string;
};

const { items, galleryId = "gallery" } = Astro.props as {
  items: Item[];
  galleryId?: string;
};
---

<div data-gl-root data-gallery-id={galleryId}>
  <!-- Grid -->
  <div class="grid grid-cols-2 gap-3 md:grid-cols-3 md:gap-4" data-gallery>
    {items.map((item, index) => (
      <button
        type="button"
        class="group relative overflow-hidden rounded-2xl border border-white/10 bg-white/5 text-left hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-white/30"
        data-gallery-item
        data-src={item.src}
        data-alt={item.alt}
        aria-label={"Abrir imagen: " + item.alt}
        title={item.alt}
      >
        <img
          src={item.src}
          alt={item.alt}
          class="aspect-square w-full object-cover transition duration-300 group-hover:scale-[1.03]"
          loading={index < 6 ? "eager" : "lazy"}
          decoding="async"
          fetchpriority={index < 2 ? "high" : "auto"}
        />
      </button>
    ))}
  </div>

  <!-- Lightbox (moved to <body> by JS) -->
  <div
    class="fixed inset-0 z-[9999] hidden"
    data-lightbox
    aria-hidden="true"
    role="dialog"
    aria-modal="true"
  >
    <!-- Backdrop -->
    <button
      type="button"
      class="absolute inset-0 bg-black/80 opacity-0 transition-opacity duration-200"
      data-lb-backdrop
      data-lb-close
      aria-label="Cerrar"
    ></button>

    <!-- Panel -->
    <div class="relative mx-auto flex h-full max-w-6xl items-center justify-center px-4">
      <div
        class="relative w-full opacity-0 scale-[0.985] transition duration-200"
        data-lb-panel
      >
        <!-- Top bar -->
        <div class="pointer-events-none absolute left-0 right-0 top-0 z-10 flex items-center justify-between p-3">
          <div
            class="pointer-events-auto rounded-full border border-white/10 bg-zinc-950/70 px-3 py-1 text-xs font-semibold text-white backdrop-blur"
            data-lb-counter
          >
            1 / 1
          </div>

          <button
            type="button"
            class="pointer-events-auto rounded-full border border-white/10 bg-zinc-950/70 px-3 py-1 text-xs font-semibold text-white backdrop-blur hover:bg-zinc-900/70"
            data-lb-close
            data-lb-close-top
            aria-label="Cerrar"
          >
            Cerrar ✕
          </button>
        </div>

        <!-- Prev/Next -->
        <button
          type="button"
          class="absolute left-0 top-1/2 z-10 -translate-y-1/2 rounded-2xl border border-white/10 bg-zinc-950/70 px-3 py-3 text-white backdrop-blur hover:bg-zinc-900/70"
          data-lb-prev
          aria-label="Anterior"
        >
          ‹
        </button>

        <button
          type="button"
          class="absolute right-0 top-1/2 z-10 -translate-y-1/2 rounded-2xl border border-white/10 bg-zinc-950/70 px-3 py-3 text-white backdrop-blur hover:bg-zinc-900/70"
          data-lb-next
          aria-label="Siguiente"
        >
          ›
        </button>

        <!-- Image area -->
        <figure
          class="mx-auto flex max-h-[85svh] items-center justify-center select-none"
          data-lb-gesture
        >
          <div class="relative">
            <img
              data-lb-img
              src=""
              alt=""
              class="max-h-[85svh] w-auto max-w-full rounded-3xl border border-white/10 bg-black/20 object-contain shadow-2xl opacity-0 transition-opacity duration-200"
              draggable="false"
            />

            <!-- Loading -->
            <div
              data-lb-loading
              class="pointer-events-none absolute inset-x-0 -bottom-10 text-center text-xs text-zinc-400 hidden"
            >
              Cargando…
            </div>

            <!-- Error -->
            <div
              data-lb-error
              class="pointer-events-none absolute inset-x-0 -bottom-10 text-center text-xs text-red-200 hidden"
            >
              No se pudo cargar la imagen.
            </div>

            <!-- Retry -->
            <div class="mt-3 flex justify-center">
              <button
                type="button"
                data-lb-retry
                class="hidden rounded-2xl border border-white/15 bg-white/5 px-4 py-2 text-xs font-semibold text-white hover:bg-white/10"
              >
                Reintentar
              </button>
            </div>
          </div>
        </figure>

        <!-- Hint -->
        <p class="mt-4 text-center text-xs text-zinc-400">
          Usa ← → o desliza. Pulsa ESC o desliza ↓ para cerrar.
        </p>

        <!-- Focus trap sentinels -->
        <span tabindex="0" data-lb-trap-start class="sr-only">start</span>
        <span tabindex="0" data-lb-trap-end class="sr-only">end</span>
      </div>
    </div>
  </div>
</div>

<script is:inline>
  (() => {
    document.querySelectorAll("[data-gl-root]").forEach((root) => {
      if (root.dataset.vigarLightboxInit === "true") return;
      root.dataset.vigarLightboxInit = "true";

      const grid = root.querySelector("[data-gallery]");
      const lb = root.querySelector("[data-lightbox]");
      if (!grid || !(lb instanceof HTMLElement)) return;

      // ✅ Portal to body (fixes "fixed inside transformed parent" issue)
      if (lb.parentElement !== document.body) document.body.appendChild(lb);

      const img = lb.querySelector("[data-lb-img]");
      const btnPrev = lb.querySelector("[data-lb-prev]");
      const btnNext = lb.querySelector("[data-lb-next]");
      const counter = lb.querySelector("[data-lb-counter]");
      const panel = lb.querySelector("[data-lb-panel]");
      const backdrop = lb.querySelector("[data-lb-backdrop]");
      const loadingEl = lb.querySelector("[data-lb-loading]");
      const errorEl = lb.querySelector("[data-lb-error]");
      const retryBtn = lb.querySelector("[data-lb-retry]");
      const closeTopBtn = lb.querySelector("[data-lb-close-top]");
      const gestureArea = lb.querySelector("[data-lb-gesture]");
      const trapStart = lb.querySelector("[data-lb-trap-start]");
      const trapEnd = lb.querySelector("[data-lb-trap-end]");

      if (!(img instanceof HTMLImageElement)) return;

      const buttons = Array.from(grid.querySelectorAll("[data-gallery-item]"));
      const items = buttons.map((b) => ({
        src: b.getAttribute("data-src") || "",
        alt: b.getAttribute("data-alt") || "",
      }));

      if (!items.length) return;

      let index = 0;
      let lastActive = null;

      // --- Scroll lock (no jump + no smooth flash) ---
      let scrollY = 0;
      let prevBodyStyle = "";
      let prevHtmlScrollBehavior = "";

      const lockScroll = () => {
        scrollY = window.scrollY || document.documentElement.scrollTop || 0;
        prevBodyStyle = document.body.getAttribute("style") || "";

        const scrollbarW = window.innerWidth - document.documentElement.clientWidth;

        document.body.style.position = "fixed";
        document.body.style.top = `-${scrollY}px`;
        document.body.style.left = "0";
        document.body.style.right = "0";
        document.body.style.width = "100%";

        if (scrollbarW > 0) document.body.style.paddingRight = `${scrollbarW}px`;
      };

      const unlockScroll = () => {
        if (prevBodyStyle) document.body.setAttribute("style", prevBodyStyle);
        else document.body.removeAttribute("style");

        const html = document.documentElement;
        prevHtmlScrollBehavior = html.style.scrollBehavior || "";
        html.style.scrollBehavior = "auto";

        window.scrollTo(0, scrollY);

        requestAnimationFrame(() => {
          html.style.scrollBehavior = prevHtmlScrollBehavior;
        });
      };
      // ---------------------------------------------

      const setLoading = (isLoading) => {
        if (loadingEl) loadingEl.classList.toggle("hidden", !isLoading);
      };

      const setError = (hasError) => {
        if (errorEl) errorEl.classList.toggle("hidden", !hasError);
        if (retryBtn instanceof HTMLElement) retryBtn.classList.toggle("hidden", !hasError);
      };

      const preload = (src) => {
        if (!src) return;
        const im = new Image();
        im.decoding = "async";
        im.src = src;
      };

      const preloadNeighbors = () => {
        const prevI = (index - 1 + items.length) % items.length;
        const nextI = (index + 1) % items.length;
        preload(items[prevI]?.src);
        preload(items[nextI]?.src);
      };

      const animateOpen = () => {
        if (backdrop instanceof HTMLElement) backdrop.style.opacity = "1";
        if (panel instanceof HTMLElement) {
          panel.style.opacity = "1";
          panel.style.transform = "scale(1)";
        }
      };

      const animateClose = () => {
        if (backdrop instanceof HTMLElement) backdrop.style.opacity = "0";
        if (panel instanceof HTMLElement) {
          panel.style.opacity = "0";
          panel.style.transform = "scale(0.985)";
        }
      };

      const render = () => {
        const it = items[index];
        if (!it) return;

        setError(false);
        setLoading(true);

        // Crossfade: fade out, swap, fade in when loaded
        img.style.opacity = "0";

        img.onload = () => {
          setLoading(false);
          img.style.opacity = "1";
          preloadNeighbors();
        };

        img.onerror = () => {
          setLoading(false);
          setError(true);
          img.style.opacity = "1";
        };

        img.src = it.src;
        img.alt = it.alt;

        if (counter) counter.textContent = `${index + 1} / ${items.length}`;
      };

      const prev = () => {
        index = (index - 1 + items.length) % items.length; // ✅ cyclic
        render();
      };

      const next = () => {
        index = (index + 1) % items.length; // ✅ cyclic
        render();
      };

      // Focus trap helpers
      const focusables = () => {
        const els = lb.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        return Array.from(els).filter((el) => el instanceof HTMLElement && !el.hasAttribute("disabled"));
      };

      const focusFirst = () => {
        const els = focusables();
        if (els[0] instanceof HTMLElement) els[0].focus();
      };

      const focusLast = () => {
        const els = focusables();
        const last = els[els.length - 1];
        if (last instanceof HTMLElement) last.focus();
      };

      const close = () => {
        animateClose();

        // Wait for close animation, then fully hide
        window.setTimeout(() => {
          lb.classList.add("hidden");
          lb.setAttribute("aria-hidden", "true");
        }, 200);

        document.removeEventListener("keydown", onKeyDown);

        unlockScroll();
        delete document.documentElement.dataset.lightboxOpen;

        if (lastActive && typeof lastActive.focus === "function") lastActive.focus();
        lastActive = null;
      };

      const open = (i) => {
        index = ((i % items.length) + items.length) % items.length;
        lastActive = document.activeElement;

        lockScroll();

        lb.classList.remove("hidden");
        lb.setAttribute("aria-hidden", "false");
        document.documentElement.dataset.lightboxOpen = "true";

        // reset animation state
        if (backdrop instanceof HTMLElement) backdrop.style.opacity = "0";
        if (panel instanceof HTMLElement) {
          panel.style.opacity = "0";
          panel.style.transform = "scale(0.985)";
        }

        render();

        requestAnimationFrame(() => {
          animateOpen();
          if (closeTopBtn instanceof HTMLElement) closeTopBtn.focus();
          else focusFirst();
        });

        document.addEventListener("keydown", onKeyDown);
      };

      const onKeyDown = (e) => {
        if (e.key === "Escape") close();
        if (e.key === "ArrowLeft") prev();
        if (e.key === "ArrowRight") next();
        if (e.key === "Tab") {
          // trap with sentinels (fallback)
          const els = focusables();
          if (!els.length) return;

          const first = els[0];
          const last = els[els.length - 1];
          const active = document.activeElement;

          if (e.shiftKey && active === first) {
            e.preventDefault();
            last.focus();
          } else if (!e.shiftKey && active === last) {
            e.preventDefault();
            first.focus();
          }
        }
      };

      // Open on click
      grid.addEventListener("click", (e) => {
        const btn = e.target.closest("[data-gallery-item]");
        if (!btn) return;
        e.preventDefault();

        const i = buttons.indexOf(btn);
        if (i === -1) return;

        open(i);
      });

      // Close (backdrop + top close)
      lb.querySelectorAll("[data-lb-close]").forEach((b) =>
        b.addEventListener("click", close)
      );

      // Prev/Next buttons
      if (btnPrev instanceof HTMLElement) btnPrev.addEventListener("click", prev);
      if (btnNext instanceof HTMLElement) btnNext.addEventListener("click", next);

      // Click/tap image => next
      if (gestureArea instanceof HTMLElement) {
        gestureArea.addEventListener("click", (e) => {
          // avoid clicks on buttons inside panel
          const t = e.target;
          if (t instanceof HTMLElement && t.closest("[data-lb-prev],[data-lb-next],[data-lb-close]")) return;
          next();
        });
      }

      // Retry
      if (retryBtn instanceof HTMLElement) {
        retryBtn.addEventListener("click", () => render());
      }

      // Focus trap sentinels (extra safety)
      if (trapStart instanceof HTMLElement) {
        trapStart.addEventListener("focus", () => focusLast());
      }
      if (trapEnd instanceof HTMLElement) {
        trapEnd.addEventListener("focus", () => focusFirst());
      }

      // Gestures: swipe left/right for prev/next, swipe down to close
      let startX = null;
      let startY = null;

      const onTouchStart = (e) => {
        const t = e.touches[0];
        if (!t) return;
        startX = t.clientX;
        startY = t.clientY;
      };

      const onTouchEnd = (e) => {
        if (startX == null || startY == null) return;

        const t = e.changedTouches[0];
        if (!t) return;

        const dx = t.clientX - startX;
        const dy = t.clientY - startY;

        startX = null;
        startY = null;

        const absX = Math.abs(dx);
        const absY = Math.abs(dy);

        // Decide intent
        if (absX < 35 && absY < 35) return;

        // Vertical close (swipe down)
        if (absY > absX && dy > 55) {
          close();
          return;
        }

        // Horizontal nav
        if (absX > absY && absX > 35) {
          if (dx > 0) prev();
          else next();
        }
      };

      if (gestureArea instanceof HTMLElement) {
        gestureArea.addEventListener("touchstart", onTouchStart, { passive: true });
        gestureArea.addEventListener("touchend", onTouchEnd, { passive: true });
      }
    });
  })();
</script>
